// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transfer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transfer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transfer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transfer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transfer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transfer_2eproto;
namespace transfer {
class DirectoryRequest;
class DirectoryRequestDefaultTypeInternal;
extern DirectoryRequestDefaultTypeInternal _DirectoryRequest_default_instance_;
class DirectoryResponse;
class DirectoryResponseDefaultTypeInternal;
extern DirectoryResponseDefaultTypeInternal _DirectoryResponse_default_instance_;
class DirectoryResponse_FileInfo;
class DirectoryResponse_FileInfoDefaultTypeInternal;
extern DirectoryResponse_FileInfoDefaultTypeInternal _DirectoryResponse_FileInfo_default_instance_;
class DownloadRequest;
class DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class DownloadRequest_FileInfo;
class DownloadRequest_FileInfoDefaultTypeInternal;
extern DownloadRequest_FileInfoDefaultTypeInternal _DownloadRequest_FileInfo_default_instance_;
class DownloadResponse;
class DownloadResponseDefaultTypeInternal;
extern DownloadResponseDefaultTypeInternal _DownloadResponse_default_instance_;
class DownloadResponse_FileResult;
class DownloadResponse_FileResultDefaultTypeInternal;
extern DownloadResponse_FileResultDefaultTypeInternal _DownloadResponse_FileResult_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class TransferControlRequest;
class TransferControlRequestDefaultTypeInternal;
extern TransferControlRequestDefaultTypeInternal _TransferControlRequest_default_instance_;
class TransferControlResponse;
class TransferControlResponseDefaultTypeInternal;
extern TransferControlResponseDefaultTypeInternal _TransferControlResponse_default_instance_;
class TransferProgressRequest;
class TransferProgressRequestDefaultTypeInternal;
extern TransferProgressRequestDefaultTypeInternal _TransferProgressRequest_default_instance_;
class TransferProgressResponse;
class TransferProgressResponseDefaultTypeInternal;
extern TransferProgressResponseDefaultTypeInternal _TransferProgressResponse_default_instance_;
class UploadRequest;
class UploadRequestDefaultTypeInternal;
extern UploadRequestDefaultTypeInternal _UploadRequest_default_instance_;
class UploadRequest_FileInfo;
class UploadRequest_FileInfoDefaultTypeInternal;
extern UploadRequest_FileInfoDefaultTypeInternal _UploadRequest_FileInfo_default_instance_;
class UploadResponse;
class UploadResponseDefaultTypeInternal;
extern UploadResponseDefaultTypeInternal _UploadResponse_default_instance_;
class UploadResponse_FileResult;
class UploadResponse_FileResultDefaultTypeInternal;
extern UploadResponse_FileResultDefaultTypeInternal _UploadResponse_FileResult_default_instance_;
}  // namespace transfer
PROTOBUF_NAMESPACE_OPEN
template<> ::transfer::DirectoryRequest* Arena::CreateMaybeMessage<::transfer::DirectoryRequest>(Arena*);
template<> ::transfer::DirectoryResponse* Arena::CreateMaybeMessage<::transfer::DirectoryResponse>(Arena*);
template<> ::transfer::DirectoryResponse_FileInfo* Arena::CreateMaybeMessage<::transfer::DirectoryResponse_FileInfo>(Arena*);
template<> ::transfer::DownloadRequest* Arena::CreateMaybeMessage<::transfer::DownloadRequest>(Arena*);
template<> ::transfer::DownloadRequest_FileInfo* Arena::CreateMaybeMessage<::transfer::DownloadRequest_FileInfo>(Arena*);
template<> ::transfer::DownloadResponse* Arena::CreateMaybeMessage<::transfer::DownloadResponse>(Arena*);
template<> ::transfer::DownloadResponse_FileResult* Arena::CreateMaybeMessage<::transfer::DownloadResponse_FileResult>(Arena*);
template<> ::transfer::RequestHeader* Arena::CreateMaybeMessage<::transfer::RequestHeader>(Arena*);
template<> ::transfer::ResponseHeader* Arena::CreateMaybeMessage<::transfer::ResponseHeader>(Arena*);
template<> ::transfer::TransferControlRequest* Arena::CreateMaybeMessage<::transfer::TransferControlRequest>(Arena*);
template<> ::transfer::TransferControlResponse* Arena::CreateMaybeMessage<::transfer::TransferControlResponse>(Arena*);
template<> ::transfer::TransferProgressRequest* Arena::CreateMaybeMessage<::transfer::TransferProgressRequest>(Arena*);
template<> ::transfer::TransferProgressResponse* Arena::CreateMaybeMessage<::transfer::TransferProgressResponse>(Arena*);
template<> ::transfer::UploadRequest* Arena::CreateMaybeMessage<::transfer::UploadRequest>(Arena*);
template<> ::transfer::UploadRequest_FileInfo* Arena::CreateMaybeMessage<::transfer::UploadRequest_FileInfo>(Arena*);
template<> ::transfer::UploadResponse* Arena::CreateMaybeMessage<::transfer::UploadResponse>(Arena*);
template<> ::transfer::UploadResponse_FileResult* Arena::CreateMaybeMessage<::transfer::UploadResponse_FileResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace transfer {

enum TransferControlRequest_ControlType : int {
  TransferControlRequest_ControlType_PAUSE = 0,
  TransferControlRequest_ControlType_RESUME = 1,
  TransferControlRequest_ControlType_CANCEL = 2,
  TransferControlRequest_ControlType_TransferControlRequest_ControlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransferControlRequest_ControlType_TransferControlRequest_ControlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransferControlRequest_ControlType_IsValid(int value);
constexpr TransferControlRequest_ControlType TransferControlRequest_ControlType_ControlType_MIN = TransferControlRequest_ControlType_PAUSE;
constexpr TransferControlRequest_ControlType TransferControlRequest_ControlType_ControlType_MAX = TransferControlRequest_ControlType_CANCEL;
constexpr int TransferControlRequest_ControlType_ControlType_ARRAYSIZE = TransferControlRequest_ControlType_ControlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferControlRequest_ControlType_descriptor();
template<typename T>
inline const std::string& TransferControlRequest_ControlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferControlRequest_ControlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferControlRequest_ControlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferControlRequest_ControlType_descriptor(), enum_t_value);
}
inline bool TransferControlRequest_ControlType_Parse(
    const std::string& name, TransferControlRequest_ControlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferControlRequest_ControlType>(
    TransferControlRequest_ControlType_descriptor(), name, value);
}
enum MessageType : int {
  UNKNOWN = 0,
  DIRECTORY = 1,
  UPLOAD = 2,
  DOWNLOAD = 3,
  TRANSFER_CONTROL = 4,
  TRANSFER_PROGRESS = 5,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = UNKNOWN;
constexpr MessageType MessageType_MAX = TRANSFER_PROGRESS;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    const std::string& name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum TransferStatus : int {
  INIT = 0,
  TRANSFERRING = 1,
  PAUSED = 2,
  COMPLETED = 3,
  FAILED = 4,
  TransferStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransferStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransferStatus_IsValid(int value);
constexpr TransferStatus TransferStatus_MIN = INIT;
constexpr TransferStatus TransferStatus_MAX = FAILED;
constexpr int TransferStatus_ARRAYSIZE = TransferStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferStatus_descriptor();
template<typename T>
inline const std::string& TransferStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferStatus_descriptor(), enum_t_value);
}
inline bool TransferStatus_Parse(
    const std::string& name, TransferStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferStatus>(
    TransferStatus_descriptor(), name, value);
}
// ===================================================================

class RequestHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const final {
    return CreateMaybeMessage<RequestHeader>(nullptr);
  }

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.RequestHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // uint64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 sequence = 4;
  void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .transfer.MessageType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::transfer::MessageType type() const;
  void set_type(::transfer::MessageType value);

  // @@protoc_insertion_point(class_scope:transfer.RequestHeader)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const final {
    return CreateMaybeMessage<ResponseHeader>(nullptr);
  }

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.ResponseHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // string error_code = 5;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 5;
  const std::string& error_code() const;
  void set_error_code(const std::string& value);
  void set_error_code(std::string&& value);
  void set_error_code(const char* value);
  void set_error_code(const char* value, size_t size);
  std::string* mutable_error_code();
  std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);

  // string error_message = 6;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 6;
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // uint64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .transfer.MessageType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::transfer::MessageType type() const;
  void set_type(::transfer::MessageType value);

  // bool success = 4;
  void clear_success();
  static const int kSuccessFieldNumber = 4;
  bool success() const;
  void set_success(bool value);

  // uint64 sequence = 7;
  void clear_sequence();
  static const int kSequenceFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:transfer.ResponseHeader)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  int type_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DirectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DirectoryRequest) */ {
 public:
  DirectoryRequest();
  virtual ~DirectoryRequest();

  DirectoryRequest(const DirectoryRequest& from);
  DirectoryRequest(DirectoryRequest&& from) noexcept
    : DirectoryRequest() {
    *this = ::std::move(from);
  }

  inline DirectoryRequest& operator=(const DirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryRequest& operator=(DirectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const DirectoryRequest*>(
               &_DirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DirectoryRequest* other);
  friend void swap(DirectoryRequest& a, DirectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectoryRequest* New() const final {
    return CreateMaybeMessage<DirectoryRequest>(nullptr);
  }

  DirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectoryRequest& from);
  void MergeFrom(const DirectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DirectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string current_path = 2;
  void clear_current_path();
  static const int kCurrentPathFieldNumber = 2;
  const std::string& current_path() const;
  void set_current_path(const std::string& value);
  void set_current_path(std::string&& value);
  void set_current_path(const char* value);
  void set_current_path(const char* value, size_t size);
  std::string* mutable_current_path();
  std::string* release_current_path();
  void set_allocated_current_path(std::string* current_path);

  // string dir_name = 3;
  void clear_dir_name();
  static const int kDirNameFieldNumber = 3;
  const std::string& dir_name() const;
  void set_dir_name(const std::string& value);
  void set_dir_name(std::string&& value);
  void set_dir_name(const char* value);
  void set_dir_name(const char* value, size_t size);
  std::string* mutable_dir_name();
  std::string* release_dir_name();
  void set_allocated_dir_name(std::string* dir_name);

  // .transfer.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::RequestHeader& header() const;
  ::transfer::RequestHeader* release_header();
  ::transfer::RequestHeader* mutable_header();
  void set_allocated_header(::transfer::RequestHeader* header);

  // bool is_parent = 4;
  void clear_is_parent();
  static const int kIsParentFieldNumber = 4;
  bool is_parent() const;
  void set_is_parent(bool value);

  // @@protoc_insertion_point(class_scope:transfer.DirectoryRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dir_name_;
  ::transfer::RequestHeader* header_;
  bool is_parent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DirectoryResponse_FileInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DirectoryResponse.FileInfo) */ {
 public:
  DirectoryResponse_FileInfo();
  virtual ~DirectoryResponse_FileInfo();

  DirectoryResponse_FileInfo(const DirectoryResponse_FileInfo& from);
  DirectoryResponse_FileInfo(DirectoryResponse_FileInfo&& from) noexcept
    : DirectoryResponse_FileInfo() {
    *this = ::std::move(from);
  }

  inline DirectoryResponse_FileInfo& operator=(const DirectoryResponse_FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryResponse_FileInfo& operator=(DirectoryResponse_FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectoryResponse_FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectoryResponse_FileInfo* internal_default_instance() {
    return reinterpret_cast<const DirectoryResponse_FileInfo*>(
               &_DirectoryResponse_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DirectoryResponse_FileInfo* other);
  friend void swap(DirectoryResponse_FileInfo& a, DirectoryResponse_FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectoryResponse_FileInfo* New() const final {
    return CreateMaybeMessage<DirectoryResponse_FileInfo>(nullptr);
  }

  DirectoryResponse_FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryResponse_FileInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectoryResponse_FileInfo& from);
  void MergeFrom(const DirectoryResponse_FileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryResponse_FileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DirectoryResponse.FileInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string modify_time = 4;
  void clear_modify_time();
  static const int kModifyTimeFieldNumber = 4;
  const std::string& modify_time() const;
  void set_modify_time(const std::string& value);
  void set_modify_time(std::string&& value);
  void set_modify_time(const char* value);
  void set_modify_time(const char* value, size_t size);
  std::string* mutable_modify_time();
  std::string* release_modify_time();
  void set_allocated_modify_time(std::string* modify_time);

  // string permissions = 5;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 5;
  const std::string& permissions() const;
  void set_permissions(const std::string& value);
  void set_permissions(std::string&& value);
  void set_permissions(const char* value);
  void set_permissions(const char* value, size_t size);
  std::string* mutable_permissions();
  std::string* release_permissions();
  void set_allocated_permissions(std::string* permissions);

  // string task_id = 6;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 6;
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);

  // uint64 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // bool is_directory = 2;
  void clear_is_directory();
  static const int kIsDirectoryFieldNumber = 2;
  bool is_directory() const;
  void set_is_directory(bool value);

  // .transfer.TransferStatus status = 7;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::transfer::TransferStatus status() const;
  void set_status(::transfer::TransferStatus value);

  // @@protoc_insertion_point(class_scope:transfer.DirectoryResponse.FileInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modify_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  bool is_directory_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DirectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DirectoryResponse) */ {
 public:
  DirectoryResponse();
  virtual ~DirectoryResponse();

  DirectoryResponse(const DirectoryResponse& from);
  DirectoryResponse(DirectoryResponse&& from) noexcept
    : DirectoryResponse() {
    *this = ::std::move(from);
  }

  inline DirectoryResponse& operator=(const DirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryResponse& operator=(DirectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const DirectoryResponse*>(
               &_DirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DirectoryResponse* other);
  friend void swap(DirectoryResponse& a, DirectoryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectoryResponse* New() const final {
    return CreateMaybeMessage<DirectoryResponse>(nullptr);
  }

  DirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectoryResponse& from);
  void MergeFrom(const DirectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DirectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DirectoryResponse_FileInfo FileInfo;

  // accessors -------------------------------------------------------

  // repeated .transfer.DirectoryResponse.FileInfo files = 3;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 3;
  ::transfer::DirectoryResponse_FileInfo* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DirectoryResponse_FileInfo >*
      mutable_files();
  const ::transfer::DirectoryResponse_FileInfo& files(int index) const;
  ::transfer::DirectoryResponse_FileInfo* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DirectoryResponse_FileInfo >&
      files() const;

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // .transfer.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::ResponseHeader& header() const;
  ::transfer::ResponseHeader* release_header();
  ::transfer::ResponseHeader* mutable_header();
  void set_allocated_header(::transfer::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:transfer.DirectoryResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DirectoryResponse_FileInfo > files_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::transfer::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class UploadRequest_FileInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.UploadRequest.FileInfo) */ {
 public:
  UploadRequest_FileInfo();
  virtual ~UploadRequest_FileInfo();

  UploadRequest_FileInfo(const UploadRequest_FileInfo& from);
  UploadRequest_FileInfo(UploadRequest_FileInfo&& from) noexcept
    : UploadRequest_FileInfo() {
    *this = ::std::move(from);
  }

  inline UploadRequest_FileInfo& operator=(const UploadRequest_FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadRequest_FileInfo& operator=(UploadRequest_FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UploadRequest_FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UploadRequest_FileInfo* internal_default_instance() {
    return reinterpret_cast<const UploadRequest_FileInfo*>(
               &_UploadRequest_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(UploadRequest_FileInfo* other);
  friend void swap(UploadRequest_FileInfo& a, UploadRequest_FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UploadRequest_FileInfo* New() const final {
    return CreateMaybeMessage<UploadRequest_FileInfo>(nullptr);
  }

  UploadRequest_FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadRequest_FileInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UploadRequest_FileInfo& from);
  void MergeFrom(const UploadRequest_FileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadRequest_FileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.UploadRequest.FileInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_name = 1;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);

  // string target_path = 2;
  void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);

  // string md5 = 4;
  void clear_md5();
  static const int kMd5FieldNumber = 4;
  const std::string& md5() const;
  void set_md5(const std::string& value);
  void set_md5(std::string&& value);
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  std::string* mutable_md5();
  std::string* release_md5();
  void set_allocated_md5(std::string* md5);

  // bytes data = 8;
  void clear_data();
  static const int kDataFieldNumber = 8;
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);

  // string task_id = 10;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 10;
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);

  // string upload_id = 13;
  void clear_upload_id();
  static const int kUploadIdFieldNumber = 13;
  const std::string& upload_id() const;
  void set_upload_id(const std::string& value);
  void set_upload_id(std::string&& value);
  void set_upload_id(const char* value);
  void set_upload_id(const char* value, size_t size);
  std::string* mutable_upload_id();
  std::string* release_upload_id();
  void set_allocated_upload_id(std::string* upload_id);

  // uint64 file_size = 3;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // bool need_chunk = 5;
  void clear_need_chunk();
  static const int kNeedChunkFieldNumber = 5;
  bool need_chunk() const;
  void set_need_chunk(bool value);

  // uint32 chunk_size = 6;
  void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_size() const;
  void set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 chunk_sequence = 7;
  void clear_chunk_sequence();
  static const int kChunkSequenceFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_sequence() const;
  void set_chunk_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 checksum = 9;
  void clear_checksum();
  static const int kChecksumFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 checksum() const;
  void set_checksum(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint64 offset = 12;
  void clear_offset();
  static const int kOffsetFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .transfer.TransferStatus status = 11;
  void clear_status();
  static const int kStatusFieldNumber = 11;
  ::transfer::TransferStatus status() const;
  void set_status(::transfer::TransferStatus value);

  // @@protoc_insertion_point(class_scope:transfer.UploadRequest.FileInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upload_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size_;
  bool need_chunk_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_sequence_;
  ::PROTOBUF_NAMESPACE_ID::uint32 checksum_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class UploadRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.UploadRequest) */ {
 public:
  UploadRequest();
  virtual ~UploadRequest();

  UploadRequest(const UploadRequest& from);
  UploadRequest(UploadRequest&& from) noexcept
    : UploadRequest() {
    *this = ::std::move(from);
  }

  inline UploadRequest& operator=(const UploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadRequest& operator=(UploadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UploadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UploadRequest* internal_default_instance() {
    return reinterpret_cast<const UploadRequest*>(
               &_UploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UploadRequest* other);
  friend void swap(UploadRequest& a, UploadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UploadRequest* New() const final {
    return CreateMaybeMessage<UploadRequest>(nullptr);
  }

  UploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UploadRequest& from);
  void MergeFrom(const UploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.UploadRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UploadRequest_FileInfo FileInfo;

  // accessors -------------------------------------------------------

  // repeated .transfer.UploadRequest.FileInfo files = 2;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::transfer::UploadRequest_FileInfo* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadRequest_FileInfo >*
      mutable_files();
  const ::transfer::UploadRequest_FileInfo& files(int index) const;
  ::transfer::UploadRequest_FileInfo* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadRequest_FileInfo >&
      files() const;

  // .transfer.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::RequestHeader& header() const;
  ::transfer::RequestHeader* release_header();
  ::transfer::RequestHeader* mutable_header();
  void set_allocated_header(::transfer::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:transfer.UploadRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadRequest_FileInfo > files_;
  ::transfer::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class UploadResponse_FileResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.UploadResponse.FileResult) */ {
 public:
  UploadResponse_FileResult();
  virtual ~UploadResponse_FileResult();

  UploadResponse_FileResult(const UploadResponse_FileResult& from);
  UploadResponse_FileResult(UploadResponse_FileResult&& from) noexcept
    : UploadResponse_FileResult() {
    *this = ::std::move(from);
  }

  inline UploadResponse_FileResult& operator=(const UploadResponse_FileResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadResponse_FileResult& operator=(UploadResponse_FileResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UploadResponse_FileResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UploadResponse_FileResult* internal_default_instance() {
    return reinterpret_cast<const UploadResponse_FileResult*>(
               &_UploadResponse_FileResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UploadResponse_FileResult* other);
  friend void swap(UploadResponse_FileResult& a, UploadResponse_FileResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UploadResponse_FileResult* New() const final {
    return CreateMaybeMessage<UploadResponse_FileResult>(nullptr);
  }

  UploadResponse_FileResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadResponse_FileResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UploadResponse_FileResult& from);
  void MergeFrom(const UploadResponse_FileResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadResponse_FileResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.UploadResponse.FileResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_name = 1;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);

  // string target_path = 2;
  void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);

  // string error_message = 6;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 6;
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // bool success = 3;
  void clear_success();
  static const int kSuccessFieldNumber = 3;
  bool success() const;
  void set_success(bool value);

  // bool need_chunk = 4;
  void clear_need_chunk();
  static const int kNeedChunkFieldNumber = 4;
  bool need_chunk() const;
  void set_need_chunk(bool value);

  // int32 next_sequence = 5;
  void clear_next_sequence();
  static const int kNextSequenceFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 next_sequence() const;
  void set_next_sequence(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:transfer.UploadResponse.FileResult)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  bool need_chunk_;
  ::PROTOBUF_NAMESPACE_ID::int32 next_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class UploadResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.UploadResponse) */ {
 public:
  UploadResponse();
  virtual ~UploadResponse();

  UploadResponse(const UploadResponse& from);
  UploadResponse(UploadResponse&& from) noexcept
    : UploadResponse() {
    *this = ::std::move(from);
  }

  inline UploadResponse& operator=(const UploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadResponse& operator=(UploadResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UploadResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UploadResponse* internal_default_instance() {
    return reinterpret_cast<const UploadResponse*>(
               &_UploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(UploadResponse* other);
  friend void swap(UploadResponse& a, UploadResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UploadResponse* New() const final {
    return CreateMaybeMessage<UploadResponse>(nullptr);
  }

  UploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UploadResponse& from);
  void MergeFrom(const UploadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.UploadResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UploadResponse_FileResult FileResult;

  // accessors -------------------------------------------------------

  // repeated .transfer.UploadResponse.FileResult results = 2;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 2;
  ::transfer::UploadResponse_FileResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadResponse_FileResult >*
      mutable_results();
  const ::transfer::UploadResponse_FileResult& results(int index) const;
  ::transfer::UploadResponse_FileResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadResponse_FileResult >&
      results() const;

  // .transfer.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::ResponseHeader& header() const;
  ::transfer::ResponseHeader* release_header();
  ::transfer::ResponseHeader* mutable_header();
  void set_allocated_header(::transfer::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:transfer.UploadResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadResponse_FileResult > results_;
  ::transfer::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DownloadRequest_FileInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DownloadRequest.FileInfo) */ {
 public:
  DownloadRequest_FileInfo();
  virtual ~DownloadRequest_FileInfo();

  DownloadRequest_FileInfo(const DownloadRequest_FileInfo& from);
  DownloadRequest_FileInfo(DownloadRequest_FileInfo&& from) noexcept
    : DownloadRequest_FileInfo() {
    *this = ::std::move(from);
  }

  inline DownloadRequest_FileInfo& operator=(const DownloadRequest_FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest_FileInfo& operator=(DownloadRequest_FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadRequest_FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadRequest_FileInfo* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest_FileInfo*>(
               &_DownloadRequest_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DownloadRequest_FileInfo* other);
  friend void swap(DownloadRequest_FileInfo& a, DownloadRequest_FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DownloadRequest_FileInfo* New() const final {
    return CreateMaybeMessage<DownloadRequest_FileInfo>(nullptr);
  }

  DownloadRequest_FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadRequest_FileInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadRequest_FileInfo& from);
  void MergeFrom(const DownloadRequest_FileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRequest_FileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DownloadRequest.FileInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_name = 1;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);

  // string target_path = 2;
  void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);

  // string download_id = 5;
  void clear_download_id();
  static const int kDownloadIdFieldNumber = 5;
  const std::string& download_id() const;
  void set_download_id(const std::string& value);
  void set_download_id(std::string&& value);
  void set_download_id(const char* value);
  void set_download_id(const char* value, size_t size);
  std::string* mutable_download_id();
  std::string* release_download_id();
  void set_allocated_download_id(std::string* download_id);

  // uint64 offset = 4;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 chunk_size = 3;
  void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_size() const;
  void set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:transfer.DownloadRequest.FileInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr download_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DownloadRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DownloadRequest) */ {
 public:
  DownloadRequest();
  virtual ~DownloadRequest();

  DownloadRequest(const DownloadRequest& from);
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DownloadRequest* other);
  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DownloadRequest* New() const final {
    return CreateMaybeMessage<DownloadRequest>(nullptr);
  }

  DownloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadRequest& from);
  void MergeFrom(const DownloadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DownloadRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DownloadRequest_FileInfo FileInfo;

  // accessors -------------------------------------------------------

  // repeated .transfer.DownloadRequest.FileInfo files = 2;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::transfer::DownloadRequest_FileInfo* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadRequest_FileInfo >*
      mutable_files();
  const ::transfer::DownloadRequest_FileInfo& files(int index) const;
  ::transfer::DownloadRequest_FileInfo* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadRequest_FileInfo >&
      files() const;

  // .transfer.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::RequestHeader& header() const;
  ::transfer::RequestHeader* release_header();
  ::transfer::RequestHeader* mutable_header();
  void set_allocated_header(::transfer::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:transfer.DownloadRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadRequest_FileInfo > files_;
  ::transfer::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DownloadResponse_FileResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DownloadResponse.FileResult) */ {
 public:
  DownloadResponse_FileResult();
  virtual ~DownloadResponse_FileResult();

  DownloadResponse_FileResult(const DownloadResponse_FileResult& from);
  DownloadResponse_FileResult(DownloadResponse_FileResult&& from) noexcept
    : DownloadResponse_FileResult() {
    *this = ::std::move(from);
  }

  inline DownloadResponse_FileResult& operator=(const DownloadResponse_FileResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadResponse_FileResult& operator=(DownloadResponse_FileResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadResponse_FileResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadResponse_FileResult* internal_default_instance() {
    return reinterpret_cast<const DownloadResponse_FileResult*>(
               &_DownloadResponse_FileResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DownloadResponse_FileResult* other);
  friend void swap(DownloadResponse_FileResult& a, DownloadResponse_FileResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DownloadResponse_FileResult* New() const final {
    return CreateMaybeMessage<DownloadResponse_FileResult>(nullptr);
  }

  DownloadResponse_FileResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadResponse_FileResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadResponse_FileResult& from);
  void MergeFrom(const DownloadResponse_FileResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadResponse_FileResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DownloadResponse.FileResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_name = 1;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);

  // string target_path = 2;
  void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);

  // string md5 = 5;
  void clear_md5();
  static const int kMd5FieldNumber = 5;
  const std::string& md5() const;
  void set_md5(const std::string& value);
  void set_md5(std::string&& value);
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  std::string* mutable_md5();
  std::string* release_md5();
  void set_allocated_md5(std::string* md5);

  // bytes data = 9;
  void clear_data();
  static const int kDataFieldNumber = 9;
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);

  // string error_message = 12;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 12;
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // uint64 file_size = 4;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // bool exists = 3;
  void clear_exists();
  static const int kExistsFieldNumber = 3;
  bool exists() const;
  void set_exists(bool value);

  // bool need_chunk = 6;
  void clear_need_chunk();
  static const int kNeedChunkFieldNumber = 6;
  bool need_chunk() const;
  void set_need_chunk(bool value);

  // bool is_last = 11;
  void clear_is_last();
  static const int kIsLastFieldNumber = 11;
  bool is_last() const;
  void set_is_last(bool value);

  // uint32 chunk_size = 7;
  void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_size() const;
  void set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 chunk_sequence = 8;
  void clear_chunk_sequence();
  static const int kChunkSequenceFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_sequence() const;
  void set_chunk_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 checksum = 10;
  void clear_checksum();
  static const int kChecksumFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 checksum() const;
  void set_checksum(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:transfer.DownloadResponse.FileResult)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size_;
  bool exists_;
  bool need_chunk_;
  bool is_last_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunk_sequence_;
  ::PROTOBUF_NAMESPACE_ID::uint32 checksum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class DownloadResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.DownloadResponse) */ {
 public:
  DownloadResponse();
  virtual ~DownloadResponse();

  DownloadResponse(const DownloadResponse& from);
  DownloadResponse(DownloadResponse&& from) noexcept
    : DownloadResponse() {
    *this = ::std::move(from);
  }

  inline DownloadResponse& operator=(const DownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadResponse& operator=(DownloadResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadResponse*>(
               &_DownloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DownloadResponse* other);
  friend void swap(DownloadResponse& a, DownloadResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DownloadResponse* New() const final {
    return CreateMaybeMessage<DownloadResponse>(nullptr);
  }

  DownloadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadResponse& from);
  void MergeFrom(const DownloadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.DownloadResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DownloadResponse_FileResult FileResult;

  // accessors -------------------------------------------------------

  // repeated .transfer.DownloadResponse.FileResult results = 2;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 2;
  ::transfer::DownloadResponse_FileResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadResponse_FileResult >*
      mutable_results();
  const ::transfer::DownloadResponse_FileResult& results(int index) const;
  ::transfer::DownloadResponse_FileResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadResponse_FileResult >&
      results() const;

  // .transfer.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::ResponseHeader& header() const;
  ::transfer::ResponseHeader* release_header();
  ::transfer::ResponseHeader* mutable_header();
  void set_allocated_header(::transfer::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:transfer.DownloadResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadResponse_FileResult > results_;
  ::transfer::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class TransferControlRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.TransferControlRequest) */ {
 public:
  TransferControlRequest();
  virtual ~TransferControlRequest();

  TransferControlRequest(const TransferControlRequest& from);
  TransferControlRequest(TransferControlRequest&& from) noexcept
    : TransferControlRequest() {
    *this = ::std::move(from);
  }

  inline TransferControlRequest& operator=(const TransferControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferControlRequest& operator=(TransferControlRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferControlRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferControlRequest* internal_default_instance() {
    return reinterpret_cast<const TransferControlRequest*>(
               &_TransferControlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TransferControlRequest* other);
  friend void swap(TransferControlRequest& a, TransferControlRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferControlRequest* New() const final {
    return CreateMaybeMessage<TransferControlRequest>(nullptr);
  }

  TransferControlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferControlRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferControlRequest& from);
  void MergeFrom(const TransferControlRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferControlRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.TransferControlRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TransferControlRequest_ControlType ControlType;
  static constexpr ControlType PAUSE =
    TransferControlRequest_ControlType_PAUSE;
  static constexpr ControlType RESUME =
    TransferControlRequest_ControlType_RESUME;
  static constexpr ControlType CANCEL =
    TransferControlRequest_ControlType_CANCEL;
  static inline bool ControlType_IsValid(int value) {
    return TransferControlRequest_ControlType_IsValid(value);
  }
  static constexpr ControlType ControlType_MIN =
    TransferControlRequest_ControlType_ControlType_MIN;
  static constexpr ControlType ControlType_MAX =
    TransferControlRequest_ControlType_ControlType_MAX;
  static constexpr int ControlType_ARRAYSIZE =
    TransferControlRequest_ControlType_ControlType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ControlType_descriptor() {
    return TransferControlRequest_ControlType_descriptor();
  }
  template<typename T>
  static inline const std::string& ControlType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ControlType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ControlType_Name.");
    return TransferControlRequest_ControlType_Name(enum_t_value);
  }
  static inline bool ControlType_Parse(const std::string& name,
      ControlType* value) {
    return TransferControlRequest_ControlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);

  // .transfer.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::RequestHeader& header() const;
  ::transfer::RequestHeader* release_header();
  ::transfer::RequestHeader* mutable_header();
  void set_allocated_header(::transfer::RequestHeader* header);

  // .transfer.TransferControlRequest.ControlType control_type = 3;
  void clear_control_type();
  static const int kControlTypeFieldNumber = 3;
  ::transfer::TransferControlRequest_ControlType control_type() const;
  void set_control_type(::transfer::TransferControlRequest_ControlType value);

  // @@protoc_insertion_point(class_scope:transfer.TransferControlRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::transfer::RequestHeader* header_;
  int control_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class TransferControlResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.TransferControlResponse) */ {
 public:
  TransferControlResponse();
  virtual ~TransferControlResponse();

  TransferControlResponse(const TransferControlResponse& from);
  TransferControlResponse(TransferControlResponse&& from) noexcept
    : TransferControlResponse() {
    *this = ::std::move(from);
  }

  inline TransferControlResponse& operator=(const TransferControlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferControlResponse& operator=(TransferControlResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferControlResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferControlResponse* internal_default_instance() {
    return reinterpret_cast<const TransferControlResponse*>(
               &_TransferControlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TransferControlResponse* other);
  friend void swap(TransferControlResponse& a, TransferControlResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferControlResponse* New() const final {
    return CreateMaybeMessage<TransferControlResponse>(nullptr);
  }

  TransferControlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferControlResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferControlResponse& from);
  void MergeFrom(const TransferControlResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferControlResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.TransferControlResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);

  // .transfer.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::ResponseHeader& header() const;
  ::transfer::ResponseHeader* release_header();
  ::transfer::ResponseHeader* mutable_header();
  void set_allocated_header(::transfer::ResponseHeader* header);

  // bool success = 3;
  void clear_success();
  static const int kSuccessFieldNumber = 3;
  bool success() const;
  void set_success(bool value);

  // .transfer.TransferStatus new_status = 4;
  void clear_new_status();
  static const int kNewStatusFieldNumber = 4;
  ::transfer::TransferStatus new_status() const;
  void set_new_status(::transfer::TransferStatus value);

  // @@protoc_insertion_point(class_scope:transfer.TransferControlResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::transfer::ResponseHeader* header_;
  bool success_;
  int new_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class TransferProgressRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.TransferProgressRequest) */ {
 public:
  TransferProgressRequest();
  virtual ~TransferProgressRequest();

  TransferProgressRequest(const TransferProgressRequest& from);
  TransferProgressRequest(TransferProgressRequest&& from) noexcept
    : TransferProgressRequest() {
    *this = ::std::move(from);
  }

  inline TransferProgressRequest& operator=(const TransferProgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferProgressRequest& operator=(TransferProgressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferProgressRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferProgressRequest* internal_default_instance() {
    return reinterpret_cast<const TransferProgressRequest*>(
               &_TransferProgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TransferProgressRequest* other);
  friend void swap(TransferProgressRequest& a, TransferProgressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferProgressRequest* New() const final {
    return CreateMaybeMessage<TransferProgressRequest>(nullptr);
  }

  TransferProgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferProgressRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferProgressRequest& from);
  void MergeFrom(const TransferProgressRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferProgressRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.TransferProgressRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);

  // .transfer.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::RequestHeader& header() const;
  ::transfer::RequestHeader* release_header();
  ::transfer::RequestHeader* mutable_header();
  void set_allocated_header(::transfer::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:transfer.TransferProgressRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::transfer::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class TransferProgressResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.TransferProgressResponse) */ {
 public:
  TransferProgressResponse();
  virtual ~TransferProgressResponse();

  TransferProgressResponse(const TransferProgressResponse& from);
  TransferProgressResponse(TransferProgressResponse&& from) noexcept
    : TransferProgressResponse() {
    *this = ::std::move(from);
  }

  inline TransferProgressResponse& operator=(const TransferProgressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferProgressResponse& operator=(TransferProgressResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferProgressResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferProgressResponse* internal_default_instance() {
    return reinterpret_cast<const TransferProgressResponse*>(
               &_TransferProgressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(TransferProgressResponse* other);
  friend void swap(TransferProgressResponse& a, TransferProgressResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferProgressResponse* New() const final {
    return CreateMaybeMessage<TransferProgressResponse>(nullptr);
  }

  TransferProgressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferProgressResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferProgressResponse& from);
  void MergeFrom(const TransferProgressResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferProgressResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.TransferProgressResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transfer_2eproto);
    return ::descriptor_table_transfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);

  // string task_name = 3;
  void clear_task_name();
  static const int kTaskNameFieldNumber = 3;
  const std::string& task_name() const;
  void set_task_name(const std::string& value);
  void set_task_name(std::string&& value);
  void set_task_name(const char* value);
  void set_task_name(const char* value, size_t size);
  std::string* mutable_task_name();
  std::string* release_task_name();
  void set_allocated_task_name(std::string* task_name);

  // .transfer.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transfer::ResponseHeader& header() const;
  ::transfer::ResponseHeader* release_header();
  ::transfer::ResponseHeader* mutable_header();
  void set_allocated_header(::transfer::ResponseHeader* header);

  // uint64 transferred_size = 5;
  void clear_transferred_size();
  static const int kTransferredSizeFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint64 transferred_size() const;
  void set_transferred_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .transfer.TransferStatus status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::transfer::TransferStatus status() const;
  void set_status(::transfer::TransferStatus value);

  // uint32 speed = 7;
  void clear_speed();
  static const int kSpeedFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed() const;
  void set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint64 total_size = 6;
  void clear_total_size();
  static const int kTotalSizeFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_size() const;
  void set_total_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 progress = 8;
  void clear_progress();
  static const int kProgressFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:transfer.TransferProgressResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_name_;
  ::transfer::ResponseHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 transferred_size_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// string session_id = 1;
inline void RequestHeader::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RequestHeader::session_id() const {
  // @@protoc_insertion_point(field_get:transfer.RequestHeader.session_id)
  return session_id_.GetNoArena();
}
inline void RequestHeader::set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.RequestHeader.session_id)
}
inline void RequestHeader::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.RequestHeader.session_id)
}
inline void RequestHeader::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.RequestHeader.session_id)
}
inline void RequestHeader::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.RequestHeader.session_id)
}
inline std::string* RequestHeader::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.RequestHeader.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestHeader::release_session_id() {
  // @@protoc_insertion_point(field_release:transfer.RequestHeader.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeader::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.RequestHeader.session_id)
}

// .transfer.MessageType type = 2;
inline void RequestHeader::clear_type() {
  type_ = 0;
}
inline ::transfer::MessageType RequestHeader::type() const {
  // @@protoc_insertion_point(field_get:transfer.RequestHeader.type)
  return static_cast< ::transfer::MessageType >(type_);
}
inline void RequestHeader::set_type(::transfer::MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:transfer.RequestHeader.type)
}

// uint64 timestamp = 3;
inline void RequestHeader::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:transfer.RequestHeader.timestamp)
  return timestamp_;
}
inline void RequestHeader::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:transfer.RequestHeader.timestamp)
}

// uint64 sequence = 4;
inline void RequestHeader::clear_sequence() {
  sequence_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestHeader::sequence() const {
  // @@protoc_insertion_point(field_get:transfer.RequestHeader.sequence)
  return sequence_;
}
inline void RequestHeader::set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:transfer.RequestHeader.sequence)
}

// -------------------------------------------------------------------

// ResponseHeader

// string session_id = 1;
inline void ResponseHeader::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResponseHeader::session_id() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.session_id)
  return session_id_.GetNoArena();
}
inline void ResponseHeader::set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.session_id)
}
inline void ResponseHeader::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.ResponseHeader.session_id)
}
inline void ResponseHeader::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.ResponseHeader.session_id)
}
inline void ResponseHeader::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.ResponseHeader.session_id)
}
inline std::string* ResponseHeader::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.ResponseHeader.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseHeader::release_session_id() {
  // @@protoc_insertion_point(field_release:transfer.ResponseHeader.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseHeader::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.ResponseHeader.session_id)
}

// .transfer.MessageType type = 2;
inline void ResponseHeader::clear_type() {
  type_ = 0;
}
inline ::transfer::MessageType ResponseHeader::type() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.type)
  return static_cast< ::transfer::MessageType >(type_);
}
inline void ResponseHeader::set_type(::transfer::MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.type)
}

// uint64 timestamp = 3;
inline void ResponseHeader::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResponseHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.timestamp)
  return timestamp_;
}
inline void ResponseHeader::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.timestamp)
}

// bool success = 4;
inline void ResponseHeader::clear_success() {
  success_ = false;
}
inline bool ResponseHeader::success() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.success)
  return success_;
}
inline void ResponseHeader::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.success)
}

// string error_code = 5;
inline void ResponseHeader::clear_error_code() {
  error_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResponseHeader::error_code() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.error_code)
  return error_code_.GetNoArena();
}
inline void ResponseHeader::set_error_code(const std::string& value) {
  
  error_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.error_code)
}
inline void ResponseHeader::set_error_code(std::string&& value) {
  
  error_code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.ResponseHeader.error_code)
}
inline void ResponseHeader::set_error_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.ResponseHeader.error_code)
}
inline void ResponseHeader::set_error_code(const char* value, size_t size) {
  
  error_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.ResponseHeader.error_code)
}
inline std::string* ResponseHeader::mutable_error_code() {
  
  // @@protoc_insertion_point(field_mutable:transfer.ResponseHeader.error_code)
  return error_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseHeader::release_error_code() {
  // @@protoc_insertion_point(field_release:transfer.ResponseHeader.error_code)
  
  return error_code_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseHeader::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  error_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_code);
  // @@protoc_insertion_point(field_set_allocated:transfer.ResponseHeader.error_code)
}

// string error_message = 6;
inline void ResponseHeader::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResponseHeader::error_message() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.error_message)
  return error_message_.GetNoArena();
}
inline void ResponseHeader::set_error_message(const std::string& value) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.error_message)
}
inline void ResponseHeader::set_error_message(std::string&& value) {
  
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.ResponseHeader.error_message)
}
inline void ResponseHeader::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.ResponseHeader.error_message)
}
inline void ResponseHeader::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.ResponseHeader.error_message)
}
inline std::string* ResponseHeader::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:transfer.ResponseHeader.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseHeader::release_error_message() {
  // @@protoc_insertion_point(field_release:transfer.ResponseHeader.error_message)
  
  return error_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseHeader::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:transfer.ResponseHeader.error_message)
}

// uint64 sequence = 7;
inline void ResponseHeader::clear_sequence() {
  sequence_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResponseHeader::sequence() const {
  // @@protoc_insertion_point(field_get:transfer.ResponseHeader.sequence)
  return sequence_;
}
inline void ResponseHeader::set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:transfer.ResponseHeader.sequence)
}

// -------------------------------------------------------------------

// DirectoryRequest

// .transfer.RequestHeader header = 1;
inline bool DirectoryRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void DirectoryRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::RequestHeader& DirectoryRequest::header() const {
  const ::transfer::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.DirectoryRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::RequestHeader*>(
      &::transfer::_RequestHeader_default_instance_);
}
inline ::transfer::RequestHeader* DirectoryRequest::release_header() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryRequest.header)
  
  ::transfer::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::RequestHeader* DirectoryRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryRequest.header)
  return header_;
}
inline void DirectoryRequest::set_allocated_header(::transfer::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryRequest.header)
}

// string current_path = 2;
inline void DirectoryRequest::clear_current_path() {
  current_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryRequest::current_path() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryRequest.current_path)
  return current_path_.GetNoArena();
}
inline void DirectoryRequest::set_current_path(const std::string& value) {
  
  current_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryRequest.current_path)
}
inline void DirectoryRequest::set_current_path(std::string&& value) {
  
  current_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryRequest.current_path)
}
inline void DirectoryRequest::set_current_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryRequest.current_path)
}
inline void DirectoryRequest::set_current_path(const char* value, size_t size) {
  
  current_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryRequest.current_path)
}
inline std::string* DirectoryRequest::mutable_current_path() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryRequest.current_path)
  return current_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryRequest::release_current_path() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryRequest.current_path)
  
  return current_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryRequest::set_allocated_current_path(std::string* current_path) {
  if (current_path != nullptr) {
    
  } else {
    
  }
  current_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_path);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryRequest.current_path)
}

// string dir_name = 3;
inline void DirectoryRequest::clear_dir_name() {
  dir_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryRequest::dir_name() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryRequest.dir_name)
  return dir_name_.GetNoArena();
}
inline void DirectoryRequest::set_dir_name(const std::string& value) {
  
  dir_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryRequest.dir_name)
}
inline void DirectoryRequest::set_dir_name(std::string&& value) {
  
  dir_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryRequest.dir_name)
}
inline void DirectoryRequest::set_dir_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dir_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryRequest.dir_name)
}
inline void DirectoryRequest::set_dir_name(const char* value, size_t size) {
  
  dir_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryRequest.dir_name)
}
inline std::string* DirectoryRequest::mutable_dir_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryRequest.dir_name)
  return dir_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryRequest::release_dir_name() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryRequest.dir_name)
  
  return dir_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryRequest::set_allocated_dir_name(std::string* dir_name) {
  if (dir_name != nullptr) {
    
  } else {
    
  }
  dir_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dir_name);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryRequest.dir_name)
}

// bool is_parent = 4;
inline void DirectoryRequest::clear_is_parent() {
  is_parent_ = false;
}
inline bool DirectoryRequest::is_parent() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryRequest.is_parent)
  return is_parent_;
}
inline void DirectoryRequest::set_is_parent(bool value) {
  
  is_parent_ = value;
  // @@protoc_insertion_point(field_set:transfer.DirectoryRequest.is_parent)
}

// -------------------------------------------------------------------

// DirectoryResponse_FileInfo

// string name = 1;
inline void DirectoryResponse_FileInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryResponse_FileInfo::name() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.name)
  return name_.GetNoArena();
}
inline void DirectoryResponse_FileInfo::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.name)
}
inline void DirectoryResponse_FileInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryResponse.FileInfo.name)
}
inline void DirectoryResponse_FileInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryResponse.FileInfo.name)
}
inline void DirectoryResponse_FileInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryResponse.FileInfo.name)
}
inline std::string* DirectoryResponse_FileInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.FileInfo.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryResponse_FileInfo::release_name() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryResponse.FileInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryResponse_FileInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryResponse.FileInfo.name)
}

// bool is_directory = 2;
inline void DirectoryResponse_FileInfo::clear_is_directory() {
  is_directory_ = false;
}
inline bool DirectoryResponse_FileInfo::is_directory() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.is_directory)
  return is_directory_;
}
inline void DirectoryResponse_FileInfo::set_is_directory(bool value) {
  
  is_directory_ = value;
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.is_directory)
}

// uint64 size = 3;
inline void DirectoryResponse_FileInfo::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DirectoryResponse_FileInfo::size() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.size)
  return size_;
}
inline void DirectoryResponse_FileInfo::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.size)
}

// string modify_time = 4;
inline void DirectoryResponse_FileInfo::clear_modify_time() {
  modify_time_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryResponse_FileInfo::modify_time() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.modify_time)
  return modify_time_.GetNoArena();
}
inline void DirectoryResponse_FileInfo::set_modify_time(const std::string& value) {
  
  modify_time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.modify_time)
}
inline void DirectoryResponse_FileInfo::set_modify_time(std::string&& value) {
  
  modify_time_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryResponse.FileInfo.modify_time)
}
inline void DirectoryResponse_FileInfo::set_modify_time(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  modify_time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryResponse.FileInfo.modify_time)
}
inline void DirectoryResponse_FileInfo::set_modify_time(const char* value, size_t size) {
  
  modify_time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryResponse.FileInfo.modify_time)
}
inline std::string* DirectoryResponse_FileInfo::mutable_modify_time() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.FileInfo.modify_time)
  return modify_time_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryResponse_FileInfo::release_modify_time() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryResponse.FileInfo.modify_time)
  
  return modify_time_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryResponse_FileInfo::set_allocated_modify_time(std::string* modify_time) {
  if (modify_time != nullptr) {
    
  } else {
    
  }
  modify_time_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modify_time);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryResponse.FileInfo.modify_time)
}

// string permissions = 5;
inline void DirectoryResponse_FileInfo::clear_permissions() {
  permissions_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryResponse_FileInfo::permissions() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.permissions)
  return permissions_.GetNoArena();
}
inline void DirectoryResponse_FileInfo::set_permissions(const std::string& value) {
  
  permissions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.permissions)
}
inline void DirectoryResponse_FileInfo::set_permissions(std::string&& value) {
  
  permissions_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryResponse.FileInfo.permissions)
}
inline void DirectoryResponse_FileInfo::set_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  permissions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryResponse.FileInfo.permissions)
}
inline void DirectoryResponse_FileInfo::set_permissions(const char* value, size_t size) {
  
  permissions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryResponse.FileInfo.permissions)
}
inline std::string* DirectoryResponse_FileInfo::mutable_permissions() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.FileInfo.permissions)
  return permissions_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryResponse_FileInfo::release_permissions() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryResponse.FileInfo.permissions)
  
  return permissions_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryResponse_FileInfo::set_allocated_permissions(std::string* permissions) {
  if (permissions != nullptr) {
    
  } else {
    
  }
  permissions_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), permissions);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryResponse.FileInfo.permissions)
}

// string task_id = 6;
inline void DirectoryResponse_FileInfo::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryResponse_FileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.task_id)
  return task_id_.GetNoArena();
}
inline void DirectoryResponse_FileInfo::set_task_id(const std::string& value) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.task_id)
}
inline void DirectoryResponse_FileInfo::set_task_id(std::string&& value) {
  
  task_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryResponse.FileInfo.task_id)
}
inline void DirectoryResponse_FileInfo::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryResponse.FileInfo.task_id)
}
inline void DirectoryResponse_FileInfo::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryResponse.FileInfo.task_id)
}
inline std::string* DirectoryResponse_FileInfo::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.FileInfo.task_id)
  return task_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryResponse_FileInfo::release_task_id() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryResponse.FileInfo.task_id)
  
  return task_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryResponse_FileInfo::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryResponse.FileInfo.task_id)
}

// .transfer.TransferStatus status = 7;
inline void DirectoryResponse_FileInfo::clear_status() {
  status_ = 0;
}
inline ::transfer::TransferStatus DirectoryResponse_FileInfo::status() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.FileInfo.status)
  return static_cast< ::transfer::TransferStatus >(status_);
}
inline void DirectoryResponse_FileInfo::set_status(::transfer::TransferStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.FileInfo.status)
}

// -------------------------------------------------------------------

// DirectoryResponse

// .transfer.ResponseHeader header = 1;
inline bool DirectoryResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void DirectoryResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::ResponseHeader& DirectoryResponse::header() const {
  const ::transfer::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::ResponseHeader*>(
      &::transfer::_ResponseHeader_default_instance_);
}
inline ::transfer::ResponseHeader* DirectoryResponse::release_header() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryResponse.header)
  
  ::transfer::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::ResponseHeader* DirectoryResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.header)
  return header_;
}
inline void DirectoryResponse::set_allocated_header(::transfer::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryResponse.header)
}

// string path = 2;
inline void DirectoryResponse::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DirectoryResponse::path() const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.path)
  return path_.GetNoArena();
}
inline void DirectoryResponse::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DirectoryResponse.path)
}
inline void DirectoryResponse::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DirectoryResponse.path)
}
inline void DirectoryResponse::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DirectoryResponse.path)
}
inline void DirectoryResponse::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DirectoryResponse.path)
}
inline std::string* DirectoryResponse::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DirectoryResponse::release_path() {
  // @@protoc_insertion_point(field_release:transfer.DirectoryResponse.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:transfer.DirectoryResponse.path)
}

// repeated .transfer.DirectoryResponse.FileInfo files = 3;
inline int DirectoryResponse::files_size() const {
  return files_.size();
}
inline void DirectoryResponse::clear_files() {
  files_.Clear();
}
inline ::transfer::DirectoryResponse_FileInfo* DirectoryResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:transfer.DirectoryResponse.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DirectoryResponse_FileInfo >*
DirectoryResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:transfer.DirectoryResponse.files)
  return &files_;
}
inline const ::transfer::DirectoryResponse_FileInfo& DirectoryResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:transfer.DirectoryResponse.files)
  return files_.Get(index);
}
inline ::transfer::DirectoryResponse_FileInfo* DirectoryResponse::add_files() {
  // @@protoc_insertion_point(field_add:transfer.DirectoryResponse.files)
  return files_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DirectoryResponse_FileInfo >&
DirectoryResponse::files() const {
  // @@protoc_insertion_point(field_list:transfer.DirectoryResponse.files)
  return files_;
}

// -------------------------------------------------------------------

// UploadRequest_FileInfo

// string file_name = 1;
inline void UploadRequest_FileInfo::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadRequest_FileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.file_name)
  return file_name_.GetNoArena();
}
inline void UploadRequest_FileInfo::set_file_name(const std::string& value) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.file_name)
}
inline void UploadRequest_FileInfo::set_file_name(std::string&& value) {
  
  file_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadRequest.FileInfo.file_name)
}
inline void UploadRequest_FileInfo::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadRequest.FileInfo.file_name)
}
inline void UploadRequest_FileInfo::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadRequest.FileInfo.file_name)
}
inline std::string* UploadRequest_FileInfo::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.FileInfo.file_name)
  return file_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadRequest_FileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.FileInfo.file_name)
  
  return file_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest_FileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.FileInfo.file_name)
}

// string target_path = 2;
inline void UploadRequest_FileInfo::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadRequest_FileInfo::target_path() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.target_path)
  return target_path_.GetNoArena();
}
inline void UploadRequest_FileInfo::set_target_path(const std::string& value) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.target_path)
}
inline void UploadRequest_FileInfo::set_target_path(std::string&& value) {
  
  target_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadRequest.FileInfo.target_path)
}
inline void UploadRequest_FileInfo::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadRequest.FileInfo.target_path)
}
inline void UploadRequest_FileInfo::set_target_path(const char* value, size_t size) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadRequest.FileInfo.target_path)
}
inline std::string* UploadRequest_FileInfo::mutable_target_path() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.FileInfo.target_path)
  return target_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadRequest_FileInfo::release_target_path() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.FileInfo.target_path)
  
  return target_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest_FileInfo::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.FileInfo.target_path)
}

// uint64 file_size = 3;
inline void UploadRequest_FileInfo::clear_file_size() {
  file_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UploadRequest_FileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.file_size)
  return file_size_;
}
inline void UploadRequest_FileInfo::set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.file_size)
}

// string md5 = 4;
inline void UploadRequest_FileInfo::clear_md5() {
  md5_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadRequest_FileInfo::md5() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.md5)
  return md5_.GetNoArena();
}
inline void UploadRequest_FileInfo::set_md5(const std::string& value) {
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.md5)
}
inline void UploadRequest_FileInfo::set_md5(std::string&& value) {
  
  md5_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadRequest.FileInfo.md5)
}
inline void UploadRequest_FileInfo::set_md5(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadRequest.FileInfo.md5)
}
inline void UploadRequest_FileInfo::set_md5(const char* value, size_t size) {
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadRequest.FileInfo.md5)
}
inline std::string* UploadRequest_FileInfo::mutable_md5() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.FileInfo.md5)
  return md5_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadRequest_FileInfo::release_md5() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.FileInfo.md5)
  
  return md5_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest_FileInfo::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  md5_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.FileInfo.md5)
}

// bool need_chunk = 5;
inline void UploadRequest_FileInfo::clear_need_chunk() {
  need_chunk_ = false;
}
inline bool UploadRequest_FileInfo::need_chunk() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.need_chunk)
  return need_chunk_;
}
inline void UploadRequest_FileInfo::set_need_chunk(bool value) {
  
  need_chunk_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.need_chunk)
}

// uint32 chunk_size = 6;
inline void UploadRequest_FileInfo::clear_chunk_size() {
  chunk_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UploadRequest_FileInfo::chunk_size() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.chunk_size)
  return chunk_size_;
}
inline void UploadRequest_FileInfo::set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chunk_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.chunk_size)
}

// uint32 chunk_sequence = 7;
inline void UploadRequest_FileInfo::clear_chunk_sequence() {
  chunk_sequence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UploadRequest_FileInfo::chunk_sequence() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.chunk_sequence)
  return chunk_sequence_;
}
inline void UploadRequest_FileInfo::set_chunk_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chunk_sequence_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.chunk_sequence)
}

// bytes data = 8;
inline void UploadRequest_FileInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadRequest_FileInfo::data() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.data)
  return data_.GetNoArena();
}
inline void UploadRequest_FileInfo::set_data(const std::string& value) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.data)
}
inline void UploadRequest_FileInfo::set_data(std::string&& value) {
  
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadRequest.FileInfo.data)
}
inline void UploadRequest_FileInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadRequest.FileInfo.data)
}
inline void UploadRequest_FileInfo::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadRequest.FileInfo.data)
}
inline std::string* UploadRequest_FileInfo::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.FileInfo.data)
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadRequest_FileInfo::release_data() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.FileInfo.data)
  
  return data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest_FileInfo::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.FileInfo.data)
}

// uint32 checksum = 9;
inline void UploadRequest_FileInfo::clear_checksum() {
  checksum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UploadRequest_FileInfo::checksum() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.checksum)
  return checksum_;
}
inline void UploadRequest_FileInfo::set_checksum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  checksum_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.checksum)
}

// string task_id = 10;
inline void UploadRequest_FileInfo::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadRequest_FileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.task_id)
  return task_id_.GetNoArena();
}
inline void UploadRequest_FileInfo::set_task_id(const std::string& value) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.task_id)
}
inline void UploadRequest_FileInfo::set_task_id(std::string&& value) {
  
  task_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadRequest.FileInfo.task_id)
}
inline void UploadRequest_FileInfo::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadRequest.FileInfo.task_id)
}
inline void UploadRequest_FileInfo::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadRequest.FileInfo.task_id)
}
inline std::string* UploadRequest_FileInfo::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.FileInfo.task_id)
  return task_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadRequest_FileInfo::release_task_id() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.FileInfo.task_id)
  
  return task_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest_FileInfo::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.FileInfo.task_id)
}

// .transfer.TransferStatus status = 11;
inline void UploadRequest_FileInfo::clear_status() {
  status_ = 0;
}
inline ::transfer::TransferStatus UploadRequest_FileInfo::status() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.status)
  return static_cast< ::transfer::TransferStatus >(status_);
}
inline void UploadRequest_FileInfo::set_status(::transfer::TransferStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.status)
}

// uint64 offset = 12;
inline void UploadRequest_FileInfo::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UploadRequest_FileInfo::offset() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.offset)
  return offset_;
}
inline void UploadRequest_FileInfo::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.offset)
}

// string upload_id = 13;
inline void UploadRequest_FileInfo::clear_upload_id() {
  upload_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadRequest_FileInfo::upload_id() const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.FileInfo.upload_id)
  return upload_id_.GetNoArena();
}
inline void UploadRequest_FileInfo::set_upload_id(const std::string& value) {
  
  upload_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadRequest.FileInfo.upload_id)
}
inline void UploadRequest_FileInfo::set_upload_id(std::string&& value) {
  
  upload_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadRequest.FileInfo.upload_id)
}
inline void UploadRequest_FileInfo::set_upload_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  upload_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadRequest.FileInfo.upload_id)
}
inline void UploadRequest_FileInfo::set_upload_id(const char* value, size_t size) {
  
  upload_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadRequest.FileInfo.upload_id)
}
inline std::string* UploadRequest_FileInfo::mutable_upload_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.FileInfo.upload_id)
  return upload_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadRequest_FileInfo::release_upload_id() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.FileInfo.upload_id)
  
  return upload_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest_FileInfo::set_allocated_upload_id(std::string* upload_id) {
  if (upload_id != nullptr) {
    
  } else {
    
  }
  upload_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), upload_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.FileInfo.upload_id)
}

// -------------------------------------------------------------------

// UploadRequest

// .transfer.RequestHeader header = 1;
inline bool UploadRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void UploadRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::RequestHeader& UploadRequest::header() const {
  const ::transfer::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::RequestHeader*>(
      &::transfer::_RequestHeader_default_instance_);
}
inline ::transfer::RequestHeader* UploadRequest::release_header() {
  // @@protoc_insertion_point(field_release:transfer.UploadRequest.header)
  
  ::transfer::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::RequestHeader* UploadRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.header)
  return header_;
}
inline void UploadRequest::set_allocated_header(::transfer::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadRequest.header)
}

// repeated .transfer.UploadRequest.FileInfo files = 2;
inline int UploadRequest::files_size() const {
  return files_.size();
}
inline void UploadRequest::clear_files() {
  files_.Clear();
}
inline ::transfer::UploadRequest_FileInfo* UploadRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:transfer.UploadRequest.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadRequest_FileInfo >*
UploadRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:transfer.UploadRequest.files)
  return &files_;
}
inline const ::transfer::UploadRequest_FileInfo& UploadRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:transfer.UploadRequest.files)
  return files_.Get(index);
}
inline ::transfer::UploadRequest_FileInfo* UploadRequest::add_files() {
  // @@protoc_insertion_point(field_add:transfer.UploadRequest.files)
  return files_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadRequest_FileInfo >&
UploadRequest::files() const {
  // @@protoc_insertion_point(field_list:transfer.UploadRequest.files)
  return files_;
}

// -------------------------------------------------------------------

// UploadResponse_FileResult

// string file_name = 1;
inline void UploadResponse_FileResult::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadResponse_FileResult::file_name() const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.FileResult.file_name)
  return file_name_.GetNoArena();
}
inline void UploadResponse_FileResult::set_file_name(const std::string& value) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadResponse.FileResult.file_name)
}
inline void UploadResponse_FileResult::set_file_name(std::string&& value) {
  
  file_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadResponse.FileResult.file_name)
}
inline void UploadResponse_FileResult::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadResponse.FileResult.file_name)
}
inline void UploadResponse_FileResult::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadResponse.FileResult.file_name)
}
inline std::string* UploadResponse_FileResult::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadResponse.FileResult.file_name)
  return file_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadResponse_FileResult::release_file_name() {
  // @@protoc_insertion_point(field_release:transfer.UploadResponse.FileResult.file_name)
  
  return file_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadResponse_FileResult::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadResponse.FileResult.file_name)
}

// string target_path = 2;
inline void UploadResponse_FileResult::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadResponse_FileResult::target_path() const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.FileResult.target_path)
  return target_path_.GetNoArena();
}
inline void UploadResponse_FileResult::set_target_path(const std::string& value) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadResponse.FileResult.target_path)
}
inline void UploadResponse_FileResult::set_target_path(std::string&& value) {
  
  target_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadResponse.FileResult.target_path)
}
inline void UploadResponse_FileResult::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadResponse.FileResult.target_path)
}
inline void UploadResponse_FileResult::set_target_path(const char* value, size_t size) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadResponse.FileResult.target_path)
}
inline std::string* UploadResponse_FileResult::mutable_target_path() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadResponse.FileResult.target_path)
  return target_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadResponse_FileResult::release_target_path() {
  // @@protoc_insertion_point(field_release:transfer.UploadResponse.FileResult.target_path)
  
  return target_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadResponse_FileResult::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadResponse.FileResult.target_path)
}

// bool success = 3;
inline void UploadResponse_FileResult::clear_success() {
  success_ = false;
}
inline bool UploadResponse_FileResult::success() const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.FileResult.success)
  return success_;
}
inline void UploadResponse_FileResult::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadResponse.FileResult.success)
}

// bool need_chunk = 4;
inline void UploadResponse_FileResult::clear_need_chunk() {
  need_chunk_ = false;
}
inline bool UploadResponse_FileResult::need_chunk() const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.FileResult.need_chunk)
  return need_chunk_;
}
inline void UploadResponse_FileResult::set_need_chunk(bool value) {
  
  need_chunk_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadResponse.FileResult.need_chunk)
}

// int32 next_sequence = 5;
inline void UploadResponse_FileResult::clear_next_sequence() {
  next_sequence_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UploadResponse_FileResult::next_sequence() const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.FileResult.next_sequence)
  return next_sequence_;
}
inline void UploadResponse_FileResult::set_next_sequence(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  next_sequence_ = value;
  // @@protoc_insertion_point(field_set:transfer.UploadResponse.FileResult.next_sequence)
}

// string error_message = 6;
inline void UploadResponse_FileResult::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UploadResponse_FileResult::error_message() const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.FileResult.error_message)
  return error_message_.GetNoArena();
}
inline void UploadResponse_FileResult::set_error_message(const std::string& value) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.UploadResponse.FileResult.error_message)
}
inline void UploadResponse_FileResult::set_error_message(std::string&& value) {
  
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.UploadResponse.FileResult.error_message)
}
inline void UploadResponse_FileResult::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.UploadResponse.FileResult.error_message)
}
inline void UploadResponse_FileResult::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.UploadResponse.FileResult.error_message)
}
inline std::string* UploadResponse_FileResult::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:transfer.UploadResponse.FileResult.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UploadResponse_FileResult::release_error_message() {
  // @@protoc_insertion_point(field_release:transfer.UploadResponse.FileResult.error_message)
  
  return error_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UploadResponse_FileResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadResponse.FileResult.error_message)
}

// -------------------------------------------------------------------

// UploadResponse

// .transfer.ResponseHeader header = 1;
inline bool UploadResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void UploadResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::ResponseHeader& UploadResponse::header() const {
  const ::transfer::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::ResponseHeader*>(
      &::transfer::_ResponseHeader_default_instance_);
}
inline ::transfer::ResponseHeader* UploadResponse::release_header() {
  // @@protoc_insertion_point(field_release:transfer.UploadResponse.header)
  
  ::transfer::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::ResponseHeader* UploadResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.UploadResponse.header)
  return header_;
}
inline void UploadResponse::set_allocated_header(::transfer::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.UploadResponse.header)
}

// repeated .transfer.UploadResponse.FileResult results = 2;
inline int UploadResponse::results_size() const {
  return results_.size();
}
inline void UploadResponse::clear_results() {
  results_.Clear();
}
inline ::transfer::UploadResponse_FileResult* UploadResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:transfer.UploadResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadResponse_FileResult >*
UploadResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:transfer.UploadResponse.results)
  return &results_;
}
inline const ::transfer::UploadResponse_FileResult& UploadResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:transfer.UploadResponse.results)
  return results_.Get(index);
}
inline ::transfer::UploadResponse_FileResult* UploadResponse::add_results() {
  // @@protoc_insertion_point(field_add:transfer.UploadResponse.results)
  return results_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::UploadResponse_FileResult >&
UploadResponse::results() const {
  // @@protoc_insertion_point(field_list:transfer.UploadResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// DownloadRequest_FileInfo

// string file_name = 1;
inline void DownloadRequest_FileInfo::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadRequest_FileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.FileInfo.file_name)
  return file_name_.GetNoArena();
}
inline void DownloadRequest_FileInfo::set_file_name(const std::string& value) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadRequest.FileInfo.file_name)
}
inline void DownloadRequest_FileInfo::set_file_name(std::string&& value) {
  
  file_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadRequest.FileInfo.file_name)
}
inline void DownloadRequest_FileInfo::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadRequest.FileInfo.file_name)
}
inline void DownloadRequest_FileInfo::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadRequest.FileInfo.file_name)
}
inline std::string* DownloadRequest_FileInfo::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadRequest.FileInfo.file_name)
  return file_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadRequest_FileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:transfer.DownloadRequest.FileInfo.file_name)
  
  return file_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadRequest_FileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadRequest.FileInfo.file_name)
}

// string target_path = 2;
inline void DownloadRequest_FileInfo::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadRequest_FileInfo::target_path() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.FileInfo.target_path)
  return target_path_.GetNoArena();
}
inline void DownloadRequest_FileInfo::set_target_path(const std::string& value) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadRequest.FileInfo.target_path)
}
inline void DownloadRequest_FileInfo::set_target_path(std::string&& value) {
  
  target_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadRequest.FileInfo.target_path)
}
inline void DownloadRequest_FileInfo::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadRequest.FileInfo.target_path)
}
inline void DownloadRequest_FileInfo::set_target_path(const char* value, size_t size) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadRequest.FileInfo.target_path)
}
inline std::string* DownloadRequest_FileInfo::mutable_target_path() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadRequest.FileInfo.target_path)
  return target_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadRequest_FileInfo::release_target_path() {
  // @@protoc_insertion_point(field_release:transfer.DownloadRequest.FileInfo.target_path)
  
  return target_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadRequest_FileInfo::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadRequest.FileInfo.target_path)
}

// uint32 chunk_size = 3;
inline void DownloadRequest_FileInfo::clear_chunk_size() {
  chunk_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DownloadRequest_FileInfo::chunk_size() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.FileInfo.chunk_size)
  return chunk_size_;
}
inline void DownloadRequest_FileInfo::set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chunk_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadRequest.FileInfo.chunk_size)
}

// uint64 offset = 4;
inline void DownloadRequest_FileInfo::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DownloadRequest_FileInfo::offset() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.FileInfo.offset)
  return offset_;
}
inline void DownloadRequest_FileInfo::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadRequest.FileInfo.offset)
}

// string download_id = 5;
inline void DownloadRequest_FileInfo::clear_download_id() {
  download_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadRequest_FileInfo::download_id() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.FileInfo.download_id)
  return download_id_.GetNoArena();
}
inline void DownloadRequest_FileInfo::set_download_id(const std::string& value) {
  
  download_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadRequest.FileInfo.download_id)
}
inline void DownloadRequest_FileInfo::set_download_id(std::string&& value) {
  
  download_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadRequest.FileInfo.download_id)
}
inline void DownloadRequest_FileInfo::set_download_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  download_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadRequest.FileInfo.download_id)
}
inline void DownloadRequest_FileInfo::set_download_id(const char* value, size_t size) {
  
  download_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadRequest.FileInfo.download_id)
}
inline std::string* DownloadRequest_FileInfo::mutable_download_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadRequest.FileInfo.download_id)
  return download_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadRequest_FileInfo::release_download_id() {
  // @@protoc_insertion_point(field_release:transfer.DownloadRequest.FileInfo.download_id)
  
  return download_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadRequest_FileInfo::set_allocated_download_id(std::string* download_id) {
  if (download_id != nullptr) {
    
  } else {
    
  }
  download_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), download_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadRequest.FileInfo.download_id)
}

// -------------------------------------------------------------------

// DownloadRequest

// .transfer.RequestHeader header = 1;
inline bool DownloadRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void DownloadRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::RequestHeader& DownloadRequest::header() const {
  const ::transfer::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::RequestHeader*>(
      &::transfer::_RequestHeader_default_instance_);
}
inline ::transfer::RequestHeader* DownloadRequest::release_header() {
  // @@protoc_insertion_point(field_release:transfer.DownloadRequest.header)
  
  ::transfer::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::RequestHeader* DownloadRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.DownloadRequest.header)
  return header_;
}
inline void DownloadRequest::set_allocated_header(::transfer::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadRequest.header)
}

// repeated .transfer.DownloadRequest.FileInfo files = 2;
inline int DownloadRequest::files_size() const {
  return files_.size();
}
inline void DownloadRequest::clear_files() {
  files_.Clear();
}
inline ::transfer::DownloadRequest_FileInfo* DownloadRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:transfer.DownloadRequest.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadRequest_FileInfo >*
DownloadRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:transfer.DownloadRequest.files)
  return &files_;
}
inline const ::transfer::DownloadRequest_FileInfo& DownloadRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:transfer.DownloadRequest.files)
  return files_.Get(index);
}
inline ::transfer::DownloadRequest_FileInfo* DownloadRequest::add_files() {
  // @@protoc_insertion_point(field_add:transfer.DownloadRequest.files)
  return files_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadRequest_FileInfo >&
DownloadRequest::files() const {
  // @@protoc_insertion_point(field_list:transfer.DownloadRequest.files)
  return files_;
}

// -------------------------------------------------------------------

// DownloadResponse_FileResult

// string file_name = 1;
inline void DownloadResponse_FileResult::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadResponse_FileResult::file_name() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.file_name)
  return file_name_.GetNoArena();
}
inline void DownloadResponse_FileResult::set_file_name(const std::string& value) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.file_name)
}
inline void DownloadResponse_FileResult::set_file_name(std::string&& value) {
  
  file_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadResponse.FileResult.file_name)
}
inline void DownloadResponse_FileResult::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadResponse.FileResult.file_name)
}
inline void DownloadResponse_FileResult::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadResponse.FileResult.file_name)
}
inline std::string* DownloadResponse_FileResult::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.FileResult.file_name)
  return file_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadResponse_FileResult::release_file_name() {
  // @@protoc_insertion_point(field_release:transfer.DownloadResponse.FileResult.file_name)
  
  return file_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadResponse_FileResult::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadResponse.FileResult.file_name)
}

// string target_path = 2;
inline void DownloadResponse_FileResult::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadResponse_FileResult::target_path() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.target_path)
  return target_path_.GetNoArena();
}
inline void DownloadResponse_FileResult::set_target_path(const std::string& value) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.target_path)
}
inline void DownloadResponse_FileResult::set_target_path(std::string&& value) {
  
  target_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadResponse.FileResult.target_path)
}
inline void DownloadResponse_FileResult::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadResponse.FileResult.target_path)
}
inline void DownloadResponse_FileResult::set_target_path(const char* value, size_t size) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadResponse.FileResult.target_path)
}
inline std::string* DownloadResponse_FileResult::mutable_target_path() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.FileResult.target_path)
  return target_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadResponse_FileResult::release_target_path() {
  // @@protoc_insertion_point(field_release:transfer.DownloadResponse.FileResult.target_path)
  
  return target_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadResponse_FileResult::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadResponse.FileResult.target_path)
}

// bool exists = 3;
inline void DownloadResponse_FileResult::clear_exists() {
  exists_ = false;
}
inline bool DownloadResponse_FileResult::exists() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.exists)
  return exists_;
}
inline void DownloadResponse_FileResult::set_exists(bool value) {
  
  exists_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.exists)
}

// uint64 file_size = 4;
inline void DownloadResponse_FileResult::clear_file_size() {
  file_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DownloadResponse_FileResult::file_size() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.file_size)
  return file_size_;
}
inline void DownloadResponse_FileResult::set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.file_size)
}

// string md5 = 5;
inline void DownloadResponse_FileResult::clear_md5() {
  md5_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadResponse_FileResult::md5() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.md5)
  return md5_.GetNoArena();
}
inline void DownloadResponse_FileResult::set_md5(const std::string& value) {
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.md5)
}
inline void DownloadResponse_FileResult::set_md5(std::string&& value) {
  
  md5_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadResponse.FileResult.md5)
}
inline void DownloadResponse_FileResult::set_md5(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadResponse.FileResult.md5)
}
inline void DownloadResponse_FileResult::set_md5(const char* value, size_t size) {
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadResponse.FileResult.md5)
}
inline std::string* DownloadResponse_FileResult::mutable_md5() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.FileResult.md5)
  return md5_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadResponse_FileResult::release_md5() {
  // @@protoc_insertion_point(field_release:transfer.DownloadResponse.FileResult.md5)
  
  return md5_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadResponse_FileResult::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  md5_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadResponse.FileResult.md5)
}

// bool need_chunk = 6;
inline void DownloadResponse_FileResult::clear_need_chunk() {
  need_chunk_ = false;
}
inline bool DownloadResponse_FileResult::need_chunk() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.need_chunk)
  return need_chunk_;
}
inline void DownloadResponse_FileResult::set_need_chunk(bool value) {
  
  need_chunk_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.need_chunk)
}

// uint32 chunk_size = 7;
inline void DownloadResponse_FileResult::clear_chunk_size() {
  chunk_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DownloadResponse_FileResult::chunk_size() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.chunk_size)
  return chunk_size_;
}
inline void DownloadResponse_FileResult::set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chunk_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.chunk_size)
}

// uint32 chunk_sequence = 8;
inline void DownloadResponse_FileResult::clear_chunk_sequence() {
  chunk_sequence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DownloadResponse_FileResult::chunk_sequence() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.chunk_sequence)
  return chunk_sequence_;
}
inline void DownloadResponse_FileResult::set_chunk_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chunk_sequence_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.chunk_sequence)
}

// bytes data = 9;
inline void DownloadResponse_FileResult::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadResponse_FileResult::data() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.data)
  return data_.GetNoArena();
}
inline void DownloadResponse_FileResult::set_data(const std::string& value) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.data)
}
inline void DownloadResponse_FileResult::set_data(std::string&& value) {
  
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadResponse.FileResult.data)
}
inline void DownloadResponse_FileResult::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadResponse.FileResult.data)
}
inline void DownloadResponse_FileResult::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadResponse.FileResult.data)
}
inline std::string* DownloadResponse_FileResult::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.FileResult.data)
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadResponse_FileResult::release_data() {
  // @@protoc_insertion_point(field_release:transfer.DownloadResponse.FileResult.data)
  
  return data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadResponse_FileResult::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadResponse.FileResult.data)
}

// uint32 checksum = 10;
inline void DownloadResponse_FileResult::clear_checksum() {
  checksum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DownloadResponse_FileResult::checksum() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.checksum)
  return checksum_;
}
inline void DownloadResponse_FileResult::set_checksum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  checksum_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.checksum)
}

// bool is_last = 11;
inline void DownloadResponse_FileResult::clear_is_last() {
  is_last_ = false;
}
inline bool DownloadResponse_FileResult::is_last() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.is_last)
  return is_last_;
}
inline void DownloadResponse_FileResult::set_is_last(bool value) {
  
  is_last_ = value;
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.is_last)
}

// string error_message = 12;
inline void DownloadResponse_FileResult::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadResponse_FileResult::error_message() const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.FileResult.error_message)
  return error_message_.GetNoArena();
}
inline void DownloadResponse_FileResult::set_error_message(const std::string& value) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.DownloadResponse.FileResult.error_message)
}
inline void DownloadResponse_FileResult::set_error_message(std::string&& value) {
  
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.DownloadResponse.FileResult.error_message)
}
inline void DownloadResponse_FileResult::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.DownloadResponse.FileResult.error_message)
}
inline void DownloadResponse_FileResult::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.DownloadResponse.FileResult.error_message)
}
inline std::string* DownloadResponse_FileResult::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.FileResult.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadResponse_FileResult::release_error_message() {
  // @@protoc_insertion_point(field_release:transfer.DownloadResponse.FileResult.error_message)
  
  return error_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadResponse_FileResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadResponse.FileResult.error_message)
}

// -------------------------------------------------------------------

// DownloadResponse

// .transfer.ResponseHeader header = 1;
inline bool DownloadResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void DownloadResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::ResponseHeader& DownloadResponse::header() const {
  const ::transfer::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::ResponseHeader*>(
      &::transfer::_ResponseHeader_default_instance_);
}
inline ::transfer::ResponseHeader* DownloadResponse::release_header() {
  // @@protoc_insertion_point(field_release:transfer.DownloadResponse.header)
  
  ::transfer::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::ResponseHeader* DownloadResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.header)
  return header_;
}
inline void DownloadResponse::set_allocated_header(::transfer::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.DownloadResponse.header)
}

// repeated .transfer.DownloadResponse.FileResult results = 2;
inline int DownloadResponse::results_size() const {
  return results_.size();
}
inline void DownloadResponse::clear_results() {
  results_.Clear();
}
inline ::transfer::DownloadResponse_FileResult* DownloadResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:transfer.DownloadResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadResponse_FileResult >*
DownloadResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:transfer.DownloadResponse.results)
  return &results_;
}
inline const ::transfer::DownloadResponse_FileResult& DownloadResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:transfer.DownloadResponse.results)
  return results_.Get(index);
}
inline ::transfer::DownloadResponse_FileResult* DownloadResponse::add_results() {
  // @@protoc_insertion_point(field_add:transfer.DownloadResponse.results)
  return results_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transfer::DownloadResponse_FileResult >&
DownloadResponse::results() const {
  // @@protoc_insertion_point(field_list:transfer.DownloadResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// TransferControlRequest

// .transfer.RequestHeader header = 1;
inline bool TransferControlRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TransferControlRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::RequestHeader& TransferControlRequest::header() const {
  const ::transfer::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.TransferControlRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::RequestHeader*>(
      &::transfer::_RequestHeader_default_instance_);
}
inline ::transfer::RequestHeader* TransferControlRequest::release_header() {
  // @@protoc_insertion_point(field_release:transfer.TransferControlRequest.header)
  
  ::transfer::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::RequestHeader* TransferControlRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.TransferControlRequest.header)
  return header_;
}
inline void TransferControlRequest::set_allocated_header(::transfer::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferControlRequest.header)
}

// string task_id = 2;
inline void TransferControlRequest::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransferControlRequest::task_id() const {
  // @@protoc_insertion_point(field_get:transfer.TransferControlRequest.task_id)
  return task_id_.GetNoArena();
}
inline void TransferControlRequest::set_task_id(const std::string& value) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.TransferControlRequest.task_id)
}
inline void TransferControlRequest::set_task_id(std::string&& value) {
  
  task_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.TransferControlRequest.task_id)
}
inline void TransferControlRequest::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.TransferControlRequest.task_id)
}
inline void TransferControlRequest::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.TransferControlRequest.task_id)
}
inline std::string* TransferControlRequest::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.TransferControlRequest.task_id)
  return task_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransferControlRequest::release_task_id() {
  // @@protoc_insertion_point(field_release:transfer.TransferControlRequest.task_id)
  
  return task_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransferControlRequest::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferControlRequest.task_id)
}

// .transfer.TransferControlRequest.ControlType control_type = 3;
inline void TransferControlRequest::clear_control_type() {
  control_type_ = 0;
}
inline ::transfer::TransferControlRequest_ControlType TransferControlRequest::control_type() const {
  // @@protoc_insertion_point(field_get:transfer.TransferControlRequest.control_type)
  return static_cast< ::transfer::TransferControlRequest_ControlType >(control_type_);
}
inline void TransferControlRequest::set_control_type(::transfer::TransferControlRequest_ControlType value) {
  
  control_type_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferControlRequest.control_type)
}

// -------------------------------------------------------------------

// TransferControlResponse

// .transfer.ResponseHeader header = 1;
inline bool TransferControlResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TransferControlResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::ResponseHeader& TransferControlResponse::header() const {
  const ::transfer::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.TransferControlResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::ResponseHeader*>(
      &::transfer::_ResponseHeader_default_instance_);
}
inline ::transfer::ResponseHeader* TransferControlResponse::release_header() {
  // @@protoc_insertion_point(field_release:transfer.TransferControlResponse.header)
  
  ::transfer::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::ResponseHeader* TransferControlResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.TransferControlResponse.header)
  return header_;
}
inline void TransferControlResponse::set_allocated_header(::transfer::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferControlResponse.header)
}

// string task_id = 2;
inline void TransferControlResponse::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransferControlResponse::task_id() const {
  // @@protoc_insertion_point(field_get:transfer.TransferControlResponse.task_id)
  return task_id_.GetNoArena();
}
inline void TransferControlResponse::set_task_id(const std::string& value) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.TransferControlResponse.task_id)
}
inline void TransferControlResponse::set_task_id(std::string&& value) {
  
  task_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.TransferControlResponse.task_id)
}
inline void TransferControlResponse::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.TransferControlResponse.task_id)
}
inline void TransferControlResponse::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.TransferControlResponse.task_id)
}
inline std::string* TransferControlResponse::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.TransferControlResponse.task_id)
  return task_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransferControlResponse::release_task_id() {
  // @@protoc_insertion_point(field_release:transfer.TransferControlResponse.task_id)
  
  return task_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransferControlResponse::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferControlResponse.task_id)
}

// bool success = 3;
inline void TransferControlResponse::clear_success() {
  success_ = false;
}
inline bool TransferControlResponse::success() const {
  // @@protoc_insertion_point(field_get:transfer.TransferControlResponse.success)
  return success_;
}
inline void TransferControlResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferControlResponse.success)
}

// .transfer.TransferStatus new_status = 4;
inline void TransferControlResponse::clear_new_status() {
  new_status_ = 0;
}
inline ::transfer::TransferStatus TransferControlResponse::new_status() const {
  // @@protoc_insertion_point(field_get:transfer.TransferControlResponse.new_status)
  return static_cast< ::transfer::TransferStatus >(new_status_);
}
inline void TransferControlResponse::set_new_status(::transfer::TransferStatus value) {
  
  new_status_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferControlResponse.new_status)
}

// -------------------------------------------------------------------

// TransferProgressRequest

// .transfer.RequestHeader header = 1;
inline bool TransferProgressRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TransferProgressRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::RequestHeader& TransferProgressRequest::header() const {
  const ::transfer::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.TransferProgressRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::RequestHeader*>(
      &::transfer::_RequestHeader_default_instance_);
}
inline ::transfer::RequestHeader* TransferProgressRequest::release_header() {
  // @@protoc_insertion_point(field_release:transfer.TransferProgressRequest.header)
  
  ::transfer::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::RequestHeader* TransferProgressRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.TransferProgressRequest.header)
  return header_;
}
inline void TransferProgressRequest::set_allocated_header(::transfer::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferProgressRequest.header)
}

// string task_id = 2;
inline void TransferProgressRequest::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransferProgressRequest::task_id() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressRequest.task_id)
  return task_id_.GetNoArena();
}
inline void TransferProgressRequest::set_task_id(const std::string& value) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.TransferProgressRequest.task_id)
}
inline void TransferProgressRequest::set_task_id(std::string&& value) {
  
  task_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.TransferProgressRequest.task_id)
}
inline void TransferProgressRequest::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.TransferProgressRequest.task_id)
}
inline void TransferProgressRequest::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.TransferProgressRequest.task_id)
}
inline std::string* TransferProgressRequest::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.TransferProgressRequest.task_id)
  return task_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransferProgressRequest::release_task_id() {
  // @@protoc_insertion_point(field_release:transfer.TransferProgressRequest.task_id)
  
  return task_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransferProgressRequest::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferProgressRequest.task_id)
}

// -------------------------------------------------------------------

// TransferProgressResponse

// .transfer.ResponseHeader header = 1;
inline bool TransferProgressResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TransferProgressResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::transfer::ResponseHeader& TransferProgressResponse::header() const {
  const ::transfer::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::transfer::ResponseHeader*>(
      &::transfer::_ResponseHeader_default_instance_);
}
inline ::transfer::ResponseHeader* TransferProgressResponse::release_header() {
  // @@protoc_insertion_point(field_release:transfer.TransferProgressResponse.header)
  
  ::transfer::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::transfer::ResponseHeader* TransferProgressResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transfer::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transfer.TransferProgressResponse.header)
  return header_;
}
inline void TransferProgressResponse::set_allocated_header(::transfer::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferProgressResponse.header)
}

// string task_id = 2;
inline void TransferProgressResponse::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransferProgressResponse::task_id() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.task_id)
  return task_id_.GetNoArena();
}
inline void TransferProgressResponse::set_task_id(const std::string& value) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.task_id)
}
inline void TransferProgressResponse::set_task_id(std::string&& value) {
  
  task_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.TransferProgressResponse.task_id)
}
inline void TransferProgressResponse::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.TransferProgressResponse.task_id)
}
inline void TransferProgressResponse::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.TransferProgressResponse.task_id)
}
inline std::string* TransferProgressResponse::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:transfer.TransferProgressResponse.task_id)
  return task_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransferProgressResponse::release_task_id() {
  // @@protoc_insertion_point(field_release:transfer.TransferProgressResponse.task_id)
  
  return task_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransferProgressResponse::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferProgressResponse.task_id)
}

// string task_name = 3;
inline void TransferProgressResponse::clear_task_name() {
  task_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransferProgressResponse::task_name() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.task_name)
  return task_name_.GetNoArena();
}
inline void TransferProgressResponse::set_task_name(const std::string& value) {
  
  task_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.task_name)
}
inline void TransferProgressResponse::set_task_name(std::string&& value) {
  
  task_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transfer.TransferProgressResponse.task_name)
}
inline void TransferProgressResponse::set_task_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transfer.TransferProgressResponse.task_name)
}
inline void TransferProgressResponse::set_task_name(const char* value, size_t size) {
  
  task_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transfer.TransferProgressResponse.task_name)
}
inline std::string* TransferProgressResponse::mutable_task_name() {
  
  // @@protoc_insertion_point(field_mutable:transfer.TransferProgressResponse.task_name)
  return task_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransferProgressResponse::release_task_name() {
  // @@protoc_insertion_point(field_release:transfer.TransferProgressResponse.task_name)
  
  return task_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransferProgressResponse::set_allocated_task_name(std::string* task_name) {
  if (task_name != nullptr) {
    
  } else {
    
  }
  task_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_name);
  // @@protoc_insertion_point(field_set_allocated:transfer.TransferProgressResponse.task_name)
}

// .transfer.TransferStatus status = 4;
inline void TransferProgressResponse::clear_status() {
  status_ = 0;
}
inline ::transfer::TransferStatus TransferProgressResponse::status() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.status)
  return static_cast< ::transfer::TransferStatus >(status_);
}
inline void TransferProgressResponse::set_status(::transfer::TransferStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.status)
}

// uint64 transferred_size = 5;
inline void TransferProgressResponse::clear_transferred_size() {
  transferred_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferProgressResponse::transferred_size() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.transferred_size)
  return transferred_size_;
}
inline void TransferProgressResponse::set_transferred_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  transferred_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.transferred_size)
}

// uint64 total_size = 6;
inline void TransferProgressResponse::clear_total_size() {
  total_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferProgressResponse::total_size() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.total_size)
  return total_size_;
}
inline void TransferProgressResponse::set_total_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  total_size_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.total_size)
}

// uint32 speed = 7;
inline void TransferProgressResponse::clear_speed() {
  speed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferProgressResponse::speed() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.speed)
  return speed_;
}
inline void TransferProgressResponse::set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.speed)
}

// uint32 progress = 8;
inline void TransferProgressResponse::clear_progress() {
  progress_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferProgressResponse::progress() const {
  // @@protoc_insertion_point(field_get:transfer.TransferProgressResponse.progress)
  return progress_;
}
inline void TransferProgressResponse::set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  progress_ = value;
  // @@protoc_insertion_point(field_set:transfer.TransferProgressResponse.progress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transfer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::transfer::TransferControlRequest_ControlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transfer::TransferControlRequest_ControlType>() {
  return ::transfer::TransferControlRequest_ControlType_descriptor();
}
template <> struct is_proto_enum< ::transfer::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transfer::MessageType>() {
  return ::transfer::MessageType_descriptor();
}
template <> struct is_proto_enum< ::transfer::TransferStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transfer::TransferStatus>() {
  return ::transfer::TransferStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transfer_2eproto
